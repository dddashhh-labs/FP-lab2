# Лабораторная работа №2: Реализация структур данных с формальной верификацией

**Цель:** Освоиться с построением пользовательских типов данных, полиморфизмом, рекурсивными алгоритмами и средствами тестирования (unit testing, property-based testing), а также разделением интерфейса и особенностей реализации. Дополнительно — применить методы формальной верификации для доказательства корректности реализации.

## Задача

В рамках лабораторной работы необходимо реализовать одну из предложенных классических структур данных на основе **AVL-дерева** (самобалансирующегося двоичного дерева поиска).

| Структура данных | Dict | Bag (Multiset) | Set |
|------------------|------|----------------|-----|
| **AVL Tree** | avl-dict | avl-bag | avl-set |

**Номер варианта:** AVL-Set

## Обязательные требования

### 1. Функциональные требования

Структура данных должна поддерживать следующие операции:

#### 1.1 Базовые операции (обязательно)

- **Добавление элементов** — вставка нового элемента в структуру
- **Удаление элементов** — удаление существующего элемента
- **Проверка наличия** — определение, содержится ли элемент в структуре

#### 1.2 Функции высшего порядка (обязательно)

- **Фильтрация** — создание новой структуры, содержащей только элементы, удовлетворяющие заданному предикату
- **Отображение (map)** — применение функции к каждому элементу структуры
- **Левая свертка (foldl)** — последовательная обработка элементов слева направо с аккумулятором
- **Правая свертка (foldr)** — последовательная обработка элементов справа налево с аккумулятором

#### 1.3 Дополнительные операции

В зависимости от выбранного интерфейса (Dict/Bag/Set):

**Для Set:**
- Объединение множеств
- Пересечение множеств
- Разность множеств
- Проверка подмножества

**Для Dict:**
- Получение значения по ключу
- Обновление значения
- Получение списка ключей/значений
- Слияние словарей

**Для Bag:**
- Количество вхождений элемента
- Добавление с множественностью
- Объединение с суммированием множественностей

### 2. Структурные требования

#### 2.1 Полиморфизм (обязательно)

Структура данных должна быть **полностью полиморфной** — работать с любыми типами данных, поддерживающими необходимые операции (например, сравнение).

**Требования:**
- Использование параметрических типов
- Поддержка type classes (Ord, Eq и др.)
- Возможность работы как с примитивными, так и с пользовательскими типами

#### 2.2 Неизменяемость (обязательно)

Все структуры данных должны быть **неизменяемыми** (immutable):
- Операции возвращают новые структуры
- Исходные данные не модифицируются
- Функциональный стиль программирования

#### 2.3 Моноид (обязательно)

Структура должна образовывать **моноид** относительно одной из операций (обычно — объединение):

**Математическое определение моноида:**
- **Ассоциативность:** `(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)`
- **Нейтральный элемент:** `∅ ⊕ a = a = a ⊕ ∅`

**Дополнительные свойства** (в зависимости от структуры):
- Коммутативность: `a ⊕ b = b ⊕ a`
- Идемпотентность: `a ⊕ a = a`

### 3. Требования к формальным доказательствам 

Формальная верификация — ключевая часть лабораторной работы. Необходимо математически строго доказать корректность реализации.

---

#### 3.1 Обязательное доказательство #1: Структура является моноидом

##### 3.1.1 Теоретическая база

**Определение моноида:**

Алгебраическая структура `(M, ⊕, e)` называется моноидом, если выполнены следующие аксиомы:

1. **Замкнутость:** для любых двух элементов множества M их композиция также принадлежит M
2. **Ассоциативность:** для любых трёх элементов a, b, c выполняется равенство `(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)`
3. **Нейтральный элемент:** существует элемент e такой, что для любого элемента a выполняется `e ⊕ a = a = a ⊕ e`

**Пример:**
- Для Set: `{1,2} ∪ {2,3} = {1,2,3}`
- Нейтральный: `∅ ∪ {1,2} = {1,2}`
- Ассоциативность: `({1} ∪ {2}) ∪ {3} = {1} ∪ ({2} ∪ {3}) = {1,2,3}`

---

#### 3.2 Обязательное доказательство #2: Обход дерева даёт правильный порядок

**Определение упорядоченности списка:**

Список называется упорядоченным (отсортированным по возрастанию), если:
- Пустой список считается упорядоченным
- Список из одного элемента считается упорядоченным
- Для списка из двух и более элементов: каждый элемент строго меньше следующего, и хвост списка также упорядочен
